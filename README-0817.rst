
About this library
==================
.. figure:: https://travis-ci.org/skojaku/multiresolcp.svg?branch=master

A Python wrapper for the c++ code of the algorithm to detect core-periphery pairs in networks generated by one-mode projection of bipartite networks.

Please cite:

`Sadamori Kojaku, Mengqiao Xu, Haoxiang Xia and Naoki Masuda. Multiscale core-periphery structure in a global liner shipping network. Preprint arXiv: 1808.04549. <http://arxiv.org/abs/1808.04549>`_

Contents
========
Python code:
  - multiresolcp/__init__.py
  - multiresolcp/MultiResolCP.py

C++ code: 
  - include/km_omp.h
  - include/km_multiresol.h
  - include/graph.h

Python - C++ interface:
  - src/_km_omp.h

Example data and code:
  - example/example.py
  - example/data/edge-list.dat 
  - example/data/capacity.dat 

Others (for PyPi registration and Travis-CI):
  - MANIFEST.in
  - requirements.txt
  - setup.py
  - .travis.yml
  - tests

Installation
============

To install, type
      
.. code-block:: bash

  pip3 install multiresolcp 

If you don't have root privilege, use -user flag, i.e.,  
      
.. code-block:: bash

  pip3 install --user multiresolcp 


Usage
=====

.. code-block:: bash
  
  import multiresolcp
  c, x = multiresolcp.detect(G, nodes_in_part1, nodes_in_part2, part_to_project, resol, node_capacity, num_samples, consensus_threshold, significance_level, num_rand_nets)

Parameters
----------

G: `NetworkX graph object <https://networkx.github.io/documentation/stable/reference/introduction.html#graphs>`_
    - Unweighted  bipartite network composed of N nodes in part 1 and M nodes in part 2 
    - Node's name can be string or number
    - Nodes in the same part should not be connected

nodes_in_part1: list of length N 
    - List of all nodes' names in part 1

nodes_in_part2: list of length M 
    - List of all nodes' names in part 2

part_to_project: string 
    - Specify the part to project onto (set either part_to_project='part1' or part_to_project='part2')

resol : float (Optional; Default resol = 1; 0<=resol)
    - Resolution parameter 

node_capacity : dict (Optional; Default node_capacity[r] = 1 for all r)
    - key : node's name (string or number) in the part NOT to project onto 
    - value : node_capacity of node
    - node_capacity is used to set the weight of edges in the projected network. Specifically, we place an edge between each pair of nodes in 'part_to_project' if the two nodes have at least one common neighbour in the bipartite network. 
      Then, we set the weight of the edge by summing 'node_capacity[r]' / (degree[r] -1) over all common neighbours r, where degree[r] is the degree of node r in the bipartite network.

num_samples: int (Optional; Default num_samples = 100; 0 < num_samples)
    - Number of CP structures detected for the same given network, which are used for the consensus clustering

consensus_threshold: float (Optional; Default consensus_threshold = 0.9; 0 <= consensus_threshold <=1)
    - Consensus threshold. If two nodes belong to the same CP pair in at least 'consensus_threshold' * 'num_samples' CP structures out of the 'num_samples' CP structures detected for the given network, we regard that the two nodes belong to the same CP pair in the consensus clustering.

significance_level: float (Optional; Default significance_level = 0.05; 0 < significance_level <=1)
    - Statistical significance level before the Šidák correction

num_rand_nets: int (Optional; Default num_rand_nets = 500; 0 < num_rand_nets)
    - Number of randomised networks used to test the statistical significance

Returns
-------

c: dict
    - key: node's name
    - value: index of the consensus CP pair to which the node belongs (the index starts from zero)

x: dict
    - key: node's name
    - value: coreness of the node

Note that c and x only contain the nodes in the consensus CP pairs.
If c and x do not contain some nodes, it means that these missing nodes do not belong to any consensus CP pair. 
If you obtain too few nodes in c and x, try decreasing the consensus threshold (i.e., consensus_threshold).
    

Examples
========

Example 1 (examples/example1.py)
--------------------------------

Suppose that we have a bipartite network composed of 18 nodes in part 1 and 9 nodes in part 2.
We intend to find core-periphery structure of the network of nodes in part 1 generated by a one-mode projection of the bipartite network. 

.. code-block:: python

	import networkx as nx
	import numpy as np
	import pandas as pd
	import multiresolcp as mcp 
	
	# Read edge list (space-separated file)
	df = pd.read_csv('data/edge-list.dat', sep=' ')
	
	# Construct NetworkX graph object
	G = nx.from_pandas_edgelist(df)
	
	# Make a list of nodes in part 1 and that of nodes in part 2
	part1 = df['source'].unique().tolist()
	part2 = df['target'].unique().tolist()
	
	# Detect core-periphery structure in the network of nodes in part 1 
	c, x = mcp.detect(G, part1, part2, part_to_project = 'part1')
	
	# Show the detected consensus CP pairs 
	print('Core-periphery structure in the network of nodes in part 1')
	for k in  sorted(c, key=c.get):
		print('%s: %d %f' % (k, c[k], x[k]))
	
	print("") 
	
	print('Core-periphery structure in the network of nodes in part 2')
	c, x = mcp.detect(G, part1, part2, part_to_project = 'part2')
	
	# Show the detected consensus CP pairs 
	for k in  sorted(c, key=c.get):
		print('%s: %d %f' % (k, c[k], x[k]))

Example 2 (examples/example2.py)
--------------------------------

In the next example, we know the node capacity of each node in part 2, i.e., a weight of each node (not degree).

.. code-block:: python

	import networkx as nx
	import numpy as np
	import pandas as pd
	import multiresolcp as mcp 
	
	# Read edge list (space-separated file)
	df = pd.read_csv('data/edge-list.dat', sep=' ')
	
	# Construct NetworkX graph object
	G = nx.from_pandas_edgelist(df)
	
	# Make a list of nodes in part 1 and that of nodes in part 2
	part1 = df['source'].unique().tolist()
	part2 = df['target'].unique().tolist()
	
	# Make a dict object of node capacities 
	df2 = pd.read_csv('data/capacity.dat', sep=' ')
	node_capacity = dict(zip(df2.name.values, df2.capacity.values))
	
	# Detect core-periphery structure in the network of nodes in part 1 
	c, x = mcp.detect(G, part1, part2, part_to_project = 'part1', node_capacity = node_capacity)
	
	# Show the detected consensus CP pairs 
	print('Core-periphery structure in the network of nodes in part 1')
	for k in  sorted(c, key=c.get):
		print('%s: %d %f' % (k, c[k], x[k]))


Requirements
============
- Python 3.4 or later
- Numpy 1.14 or later
- SciPy 1.1 or later
- NetworkX 2.0 or later
- pybind11 2.2 or later 
